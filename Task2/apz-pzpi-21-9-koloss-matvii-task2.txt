1 ХІД РОБОТИ
1.1 Концептуальне моделювання предметної області

У цьому розділі проведено концептуальне моделювання предметної області онлайн каталогу товарів. Для розуміння функціональних можливостей системи та її взаємодії з користувачами була побудована Use Case діаграма (див. рис. 1.1).
У системі існує роль адміністратора та роль менеджера. Для розуміння що робить кожна роль, було розписано таблицю 1.1.

Таблиця 1.1 – Ролі системи
Адміністратор	Обліковий запис: вхід до облікового запису, вихід з облікового запису, створення облікового запису менеджера, зміна паролю, видалення менеджерів.
Товари: створення товарів, видалення товарів, редагування товарів, пошук товарів та їх фільтрація, звітність заробітної плати.
Категорії: створення категорій товару, редагування категорій товару, видалення категорій, пошук категорій.
Сайти: створення сайтів, редагування сайтів, видалення сайтів.
Менеджер	Обліковий запис: вхід до облікового запису, вихід з облікового запису.
Товари: створення товарів, видалення товарів, редагування товарів, пошук товарів та їх фільтрація, звітність заробітної плати.
Категорії: створення категорій товару, редагування категорій товару, видалення категорій, пошук категорій.
Сайти: створення сайтів, редагування сайтів, видалення сайтів.
Клієнти	Перегляд каталогу товару з можливістю пошуку за найменуванням та фільтрацією за категорією товару.

Проаналізуємо таблицю 1.1. Адміністратори та менеджери можуть входити до облікового запису, для цього потрібно ввести логін та пароль. Однак адміністратор може створити акаунт для менеджера, який у свою чергу у майбутньому може розпочати сесію для створення товарів, редагування тощо.
У системі авторизації використано роботу з токенами, а саме JSON Web Token, який зберігає у собі інформацію про сесію та дані користувача, які вказав розробник, у даній системі це: логін та роль. Використання JWT токену забезпечує безпеку облікового запису.

1.2 Опис побудови бази даних

Створення та організація бази даних є ключовим етапом у розробці системи "Онлайн-каталог та програма організації обліку". Це важливий аспект, що впливає на ефективність та продуктивність системи. Дана база даних складатиметься з низки таблиць, які будуть взаємодіяти між собою через ключі.
Перелік атрибутів для кожної сутності:
–	адміністратор: користувач_id, логін, пароль, роль. Первинний ключ: користувач_id;
–	товар: id, назва, опис, артикул, опубліковано, ціна покупки, ціна продажу, трек номер, локація, посилання на інстаграм, продано, дата створення, дата редагування. Первинний ключ: id;
–	категорія: id, назва, батьківська категорія. Первинний ключ: id;
–	зображення: id, індекс, товар. Первинний ключ: id;
–	сайт: id, назва, товар. Первинний ключ: id.
Зв’язки бази даних:
–	“товар – категорія” – тип зв’язку багато до багатьох. Кожен товар може мати кілька категорій, а категорія може бути у багатьох товарах;
–	“зображення – товар” – тип зв’язку один до багатьох. Кожен товар може мати багато фотографій;
–	“товар – сайт” – тип зв’язку один до багатьох. Товар може мати багато сайтів, а сайт може бути у багатьох товарах.
Під час проведення аналізу атрибутів для різних сутностей та встановлення зв'язків між ними, основним акцентом були функціональні потреби користувачів системи "Онлайн-каталог та програма організації обліку". Цей процес мав на меті не лише визначення технічних аспектів структури бази даних, але й зрозуміння того, як саме дані взаємодіють між собою та як ця взаємодія впливає на функціональність та зручність користування системою для кінцевих користувачів.
Проведений аналіз допоміг ідентифікувати ключові атрибути кожної сутності, їх зв'язки та взаємодію в межах системи. Враховуючи потреби різних типів користувачів. Було важливо забезпечити, щоб дані були структуровані та організовані таким чином, щоб вони були легко доступні та зрозумілі для всіх сторін.
За допомогою цього аналізу ми змогли визначити оптимальну структуру бази даних, яка відповідає потребам користувачів і забезпечує ефективну та зручну роботу системи в цілому. Такий підхід дозволить побудувати систему, яка відповідає вимогам користувачів і забезпечує їх задоволення від використання продукту.
Щоб зрозуміти структуру даних та їх взаємозв'язки у системі "Онлайн-каталог та програма організації обліку", використовується ER-діаграма. Ця діаграма складається з різних елементів, які ілюструють ключові сутності, їх властивості та зв'язки між ними. Завдяки ER-діаграмі можна зрозуміти, як дані організовані та як вони взаємодіють один з одним у рамках системи. Дана діаграма зображена на рисунку 1.2.
Після аналізу ER-діаграми стало зрозуміло, що структура бази даних системи "Онлайн-каталог та програма організації обліку" має чіткі взаємозв'язки між ключовими сутностями. Ця діаграма надає важливу інформацію про те, як дані організовані та взаємодіють у межах системи, що допомагає забезпечити ефективну роботу програмного забезпечення. З її допомогою розробники та адміністратори можуть краще розуміти структуру системи та вносити необхідні зміни для її вдосконалення.


1.3 Серверна частина

Під час розробки серверної частини програмної системи, було використано різноманітні технології та інструменти для забезпечення оптимальної функціональності та продуктивності системи. Основна мова програмування була C#, що дозволило створити потужні та ефективні компоненти системи.
Основним фреймворком, було використано для створення RESTful API, був ASP.NET Web API. Використання цього фреймворку дозволило легко створювати веб-сервіси, які надають доступ до даних та функціональності системи через HTTP-протокол.
Для взаємодії з базою даних було обрано Entity Framework - ORM фреймворк для .NET. Entity Framework спростив процес взаємодії з базою даних MS SQL Server, дозволяючи швидко та ефективно виконувати операції з даними.
Додатково, було використано інші технології та інструменти, такі як LINQ для роботи з колекціями даних, сервіси маршрутизації для керування запитами, а також різноманітні бібліотеки та компоненти для забезпечення безпеки даних та автентифікації користувачів.
Перед тим як перейдемо до аналізу діаграми пакетів, треба коротко описати організацію компонентів програмної системи. Діаграма пакетів відображає високорівневу структуру системи, де компоненти групуються в окремі модулі або пакети. Це дозволяє нам краще розуміти, як компоненти системи організовані та як вони взаємодіють між собою. Звернемося до діаграми (див. рис. 1.3), щоб отримати більше інформації про структуру нашого програмного забезпечення.
У розробці серверної частини програмної системи на базі ASP.NET Web API були використані контролери для обробки та маршрутизації HTTP-запитів.
Контролери відповідають за приймання запитів від клієнтів, обробку їх та повернення відповідей. Кожен контролер містить методи, які виконують певні дії відповідно до отриманих запитів.
Для системи "Онлайн-каталог та програма організації обліку" були створені контролери для управління товарами, категоріями тощо. Кожен контролер може містити методи, такі як GET, POST, PUT, DELETE, які відповідають різним HTTP-запитам та забезпечують необхідну функціональність.
Система призначена для забезпечення зручного та ефективного управління товарними запасами та фінансовими операціями компанії. Вона поєднує в собі онлайн-каталог для перегляду товарів з програмою обліку для автоматизації облікових процесів.
Діаграма розгортання нижче (див. рис. 1.4) ілюструє архітектуру системи та взаємодію між її основними компонентами.
Для фільтрації товарів у системі організації обліку було розроблено метод GetFilterSpecification (див. додаток А.1). Цей метод у майбутньому потрібен для того щоб знайти товари за назвою, трек номером, артиклем, локацією, описом, а також відфільтрувати товари.
Для фільтрації товарів для користувачів розроблено метод GetFilterSpecification. Цей метод відрізняється від попереднього тим, що він знаходиться у іншому спеціальному класі та своєю унікальною фільтрацією та пошуком товару. Метод показано у додатку А.2.
Дані два методи використовуються у методі Execute (див. додаток. А.3) і потрібен він для виводу товарів, які вже відфільтровані, просортовані тощо. Метод повертає відповідь з атрибутом PageItems – це власно і є товари та ItemsCount – кількість всіх відфільтрованих товарів (потрібно для пагінації).

1.4 REST специфікація

Продукти для адміністратора:
–	GET /api/AdminProducts – отримати товари;
–	POST /api/AdminProducts – створити товар;
–	PUT /api/AdminProducts – відредагувати товар;
–	GET /api/AdminProducts/article – генерація артикуля.
Авторизація:
–	POST /api/Auth/signIn – увійти в обліковий запис;
–	POST /api/Auth/registerManager – реєстрація менеджера;
–	DELETE /api/Auth/{login} – видалити обліковий запис;
–	PATCH /api/Auth – зміна паролю;
–	POST /api/Auth/checkToken – перевірка токену авторизації.
Категорія:
–	GET /api/Categories/ – отримати усі категорії;
–	POST /api/Categories – створити категорію;
–	PUT /api/Categories – відредагувати категорію;
–	GET /api/Categories/withoutParent – отримати категорії, які немає батьківської категорії;
–	DELETE /api/Categories/{id} – видалити категорію.
Зображення:
–	GET /api/Image/{id} – отримати зображення;
–	POST /api/Image/{id} – створити зображення.
Сайти:
–	GET /api/Sites – отримати усі сайти;
–	POST /api/Sites – створити сайт;
–	PUT /api/Sites – редагування сайту;
–	DELETE /api/Sites/{id} – видалити сайт;
Продукти для клієнта:
–	GET /api/UserProducts/{id} – отримати товар за ідентифікатором;
–	GET /api/UserProducts – отримати усі товари;

ДОДАТОК А
Функції серверної частини

А.1 метод GetFilterSpecification для організації обліку

1	public override ISpecification<Product> GetFilterSpecification()
2	{
3	var lowerSearchString = SearchString?.ToLower();
4	var search = new FilterSpecification<Product>(product => string.IsNullOrEmpty(lowerSearchString) ||
5	product.Name.ToLower().Contains(lowerSearchString) ||
6	product.TrackNumber.ToLower().Contains(lowerSearchString ||
7	product.Article.ToLower().Contains(lowerSearchString) ||
8	product.Location.ToLower().Contains(lowerSearchString) ||
9	product.Description.ToLower().Contains(lowerSearchString));
10	var filter = new FilterSpecification<Product>(product =>
11	(MinEditionDate == null || product.EditionDate >= MinEditionDate) &&
12	(MaxEditionDate == null || product.EditionDate <= MaxEditionDate) &&
13	product.PurchasePrice >= MinPurchasePrice &&
14	product.PurchasePrice <= MaxPurchasePrice &&
15	product.SalePrice >= MinSalePrice && product.SalePrice <= MaxSalePrice &&
16	(CategoryIdes == null || product.Categories.Any(c => CategoryIdes.Contains(c.Id) || CategoryIdes.Any(i => i == c.ParentCategoryId))) &&
17	(SiteIdes == null || product.Sites.Any(c => SiteIdes.Contains(c.Id))));
18	var publishedFilter = PublishedFilter == BoolFilter.All ?
19	new FilterSpecification<Product>(_ => true) :
20	PublishedFilter == BoolFilter.True ?
21	new FilterSpecification<Product>(product => product.Published) :
22	new FilterSpecification<Product>(product => !product.Published);
23	var saledFilter = IsSaled == BoolFilter.All ?
24	new FilterSpecification<Product>(_ => true) :
25	IsSaled == BoolFilter.True ?
26	new FilterSpecification<Product>(product => product.IsSaled) :
27	new FilterSpecification<Product>(product => !product.IsSaled);
28	var boolFilters = new AndSpecification<Product>(saledFilter, publishedFilter);
29	return new AndSpecification<Product>(boolFilters, new AndSpecification<Product>(filter, search));
30	}

А.2 метод GetFilterSpecification для клієнтів

1	public override ISpecification<Product> GetFilterSpecification() {
2	var lowerSearchString = SearchString?.ToLower();
3	var search = new FilterSpecification<Product>(product => string.IsNullOrEmpty(lowerSearchString) ||
4	product.Name.ToLower().Contains(lowerSearchString)
5	|| product.Article.ToLower().Contains(lowerSearchString) ||
6	product.Description.ToLower().Contains(lowerSearchString));
7	var filter = new FilterSpecification<Product>(product => product.Published && !product.IsSaled &&
8	(CategoryIdes == null || product.Categories.Any(c => CategoryIdes.Contains(c.Id) || CategoryIdes.Any(i => i == c.ParentCategoryId))));
9	
10	return new AndSpecification<Product>(filter, search);
11	}

А.3 метод Execute

1	public async Task<PageResponse<T>> Execute(IQueryable<T> query)
2	{
3	return new PageResponse<T>()
4	{
5	ItemsCount = await GetOrderSpecification()
6	.Specify(GetFilterSpecification().Specify(query)).CountAsync(),
7	PageItems = await GetPaginationSpecification()
8	.Specify(GetOrderSpecification()
9	.Specify(GetFilterSpecification().Specify(query))).ToListAsync() }; }
